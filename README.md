# Лабораторная работа 1: Эрозия в компьютерном зрении

**Дисциплина:** Компьютерное зрение  
**Тема:** Эрозия  
**Выполнили:** студенты гр. P4154, P4155  
Ковалёв Артём, Мавлюкеев Артем, Касютин Илья  
**Санкт-Петербург, 2025**

## 1. Теоретическая база

### 1.1. Общая информация

Эрозия — операция в математической морфологии для анализа и обработки изображений в компьютерном зрении. Она основана на теории множеств и применяется в основном к бинарным изображениям, где объекты — белые пиксели, фон — чёрные. Эрозия уменьшает размеры объектов, удаляя внешние слои, сужая границы и устраняя мелкие детали или шум. Выполняется с помощью структурирующего элемента (ядра), задающего форму и масштаб изменений.

Эрозия используется для предварительной обработки изображений: удаления шумов (изолированные пиксели, тонкие линии), разделения соприкасающихся объектов в сегментации (например, клетки в медицинских изображениях или частицы в материалах). В сочетании с дилатацией формирует операции открытия и закрытия для баланса фильтрации и сохранения форм. Для градационных изображений адаптируется путём взятия минимума в окрестности, применимо к серым или цветным изображениям для выделения тёмных зон. Пример действия эрозии показан на рисунке 1.




Эрозия упрощает структуры изображений для дальнейшего анализа (распознавание контуров, классификация объектов) и применяется в робототехнике, биомедицине.

### 1.2. Структурный элемент

Структурный элемент (ядро, маска) — ключевой компонент морфологических операций, включая эрозию, определяющий локальную окрестность для анализа и модификации изображения. В бинарных изображениях — это подмножество пикселей в матрице фиксированного размера, с активными (1) и неактивными (0) позициями относительно центра. Центр служит опорой для наложения на каждый пиксель изображения, оценивая соответствие шаблону.

Форма и размер элемента влияют на результат: квадратная матрица 3x3 сужает границы равномерно, дисковая сохраняет плавные контуры. Асимметричные элементы возможны для анизотропных задач, но рекомендуется симметрия. Малые ядра (3x3) удаляют тонкие детали, большие (5x5+) существенно уменьшают объекты. Пример с разными размерами показан на рисунке 2.




Теоретически — множество в евклидовом пространстве или сетке для вычисления минимумов/пересечений. Для градационных изображений учитывает интенсивности. В библиотеках задаётся программно для гибкости в задачах от фильтрации шума до сегментации.

### 1.3. Алгоритм

Для бинарного изображения (объекты — 1, фон — 0) инициализируется результирующее изображение (копия исходного или пустой массив). Для каждого пикселя (x, y) накладывается структурный элемент с центром в (x, y), определяя окрестность.

Проверяется: все активные позиции элемента соответствуют объекту (1) в исходном изображении? Если да, результирующий пиксель = 1; иначе = 0. Повторяется для всех пикселей с padding по краям. При итерациях результат предыдущей становится входом. Алгоритм представлен на рисунке 3.




Для градационных изображений вычисляется минимум интенсивности в окрестности. Вычислительная сложность линейна от размера изображения и элемента; интегрируется в библиотеки с оптимизациями.

### 1.4. Реализация эрозии

Пример реализации на C++ с OpenCV (сокращённая версия только для эрозии) взят с официального сайта: [https://docs.opencv.org/3.4/db/df6/tutorial_erosion_dilatation.html](https://docs.opencv.org/3.4/db/df6/tutorial_erosion_dilatation.html).

**Краткое объяснение кода:**  
Код загружает изображение, создаёт окно с трекбарами для выбора типа (прямоугольник, крест, эллипс) и размера ядра. Функция `Erosion` генерирует структурный элемент с `getStructuringElement`, применяет `erode` для эрозии и отображает результат. Это демонстрирует интерактивную обработку: изменения трекбаров обновляют изображение в реальном времени. Основная операция — `erode(src, erosion_dst, element)`, где `src` — исходное, `element` — ядро.

```cpp
#include "opencv2/imgproc.hpp"
#include "opencv2/highgui.hpp"
#include <iostream>
using namespace cv;
using namespace std;

Mat src, erosion_dst;
int erosion_elem = 0;
int erosion_size = 0;
int const max_elem = 2;
int const max_kernel_size = 21;

void Erosion(int, void*);

int main(int argc, char** argv) {
    CommandLineParser parser(argc, argv, "{@input | LinuxLogo.jpg | input image}");
    src = imread(samples::findFile(parser.get<String>("@input")), IMREAD_COLOR);
    if (src.empty()) {
        cout << "Could not open or find the image!\n" << endl;
        cout << "Usage: " << argv[0] << " <Input image>" << endl;
        return -1;
    }
    namedWindow("Erosion Demo", WINDOW_AUTOSIZE);
    createTrackbar("Element:\n 0: Rect \n 1: Cross \n 2: Ellipse", "Erosion Demo", &erosion_elem, max_elem, Erosion);
    createTrackbar("Kernel size:\n 2n +1", "Erosion Demo", &erosion_size, max_kernel_size, Erosion);
    Erosion(0, 0);
    waitKey(0);
    return 0;
}

void Erosion(int, void*) {
    int erosion_type = 0;
    if (erosion_elem == 0) { erosion_type = MORPH_RECT; }
    else if (erosion_elem == 1) { erosion_type = MORPH_CROSS; }
    else if (erosion_elem == 2) { erosion_type = MORPH_ELLIPSE; }
    Mat element = getStructuringElement(erosion_type, Size(2 * erosion_size + 1, 2 * erosion_size + 1), Point(erosion_size, erosion_size));
    erode(src, erosion_dst, element);
    imshow("Erosion Demo", erosion_dst);
}
```
